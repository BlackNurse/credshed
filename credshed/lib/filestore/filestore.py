#!/usr/bin/env python3

# by TheTechromancer

import os
import sys
import json
import hashlib
import logging
from .util import *
from .index import *
from ..errors import *
from pathlib import Path
from .decompress import *
from ..config import credshed_config


# set up logging
log_file = '/var/log/credshed/filestore.log'
log_level = logging.DEBUG
log_format = '%(asctime)s\t%(levelname)s\t%(name)s\t%(message)s'
try:
    logging.basicConfig(level=log_level, filename=log_file, format=log_format)
except (PermissionError, FileNotFoundError):
    logging.basicConfig(level=log_level, filename='filestore.log', format=log_format)
    sys.stderr.write(f'\n[!] Unable to create log file at {log_file}, logging to current directory\n\n')
log = logging.getLogger('credshed.filestore')



class Filestore():

    def __init__(self):

        self.config = credshed_config['FILESTORE']
        self.dir = Path(self.config['store_dir']).resolve()
        self.index = FilestoreIndex(self.dir)
        self.index.read()

        # broken symlinks: {filename}
        self.file_orphans = set()
        # missing master files: {hash: filename}
        self.index_orphans = dict()

        if not self.dir.is_dir():
            raise FilestoreError(f'Invalid filestore directory: {self.dir}')


    @property
    def files(self):
        '''
        Walks the filestore and yields each file as a Path() object
            - if a broken symlink is encountered, it is added to orphans
        '''

        for filename in self.list_files(self.dir, include_symlinks=True):

            resolved_filename = filename.resolve()

            # skip files generated by this program
            if filename == self.index.file:
                continue
            elif filename.suffix.lower() == '.filestore':
                continue

            # skip the file if it links to something outside self.dir
            if not str(resolved_filename).startswith(str(self.dir)):
                log.info(f'Skipping foreign symlink to {resolved_filename}')
                continue

            # skip the file if it's empty
            if not filename.is_symlink():
                if os.stat(str(resolved_filename)).st_size == 0:
                    log.info(f'Skipping empty file {resolved_filename}')
                    continue

            # add the file to orphans if it's a broken symlink
            if not resolved_filename.exists():
                log.warning(f'Found an orphan named {filename} :(')
                self.file_orphans.add(filename)
                continue

            yield filename



    def update_index(self):

        log.info('Updating filestore index')

        # add new files to the index
        self._scan_filestore()

        # scan the index for inconsistencies
        self._scan_index()

        # try and rescue orphaned files
        log.warning(f'Found {len(self.file_orphans):,} orphans in filestore')
        self._save_file_orphans()

        # try and rescue orphaned index entries
        # self._save_index_orphans()
        log.warning(f'Found {len(self.index_orphans):,} orphans in index')

        # save the index
        self.index.write()


    def _scan_filestore(self):
        '''
        Scans the filesystem and adds new files to the index
            - if broken symlinks are encountered, adds to orphans
        '''

        for filename in self.files:

            # add new files to index
            master = self.index.add(filename)

            # if file is a duplicate of another
            if master is not None:
                # remove it and symlink to the original
                self.symlink_file(filename, master)


    def _scan_index(self):
        '''
        Scans the index
            - if master and all children are missing, delete entire entry
            - elif missing master is encountered, adds to orphans
        '''

        for filehash, (master_file, child_files) in self.index:
            # if the master file is missing
            if not master_file.exists():
                # if all the children are missing too
                if all([not (c.is_symlink() or c.is_file()) for c in child_files]):
                    # delete the entire entry
                    log.warning(f'Master {master_file} and all children are missing.')
                    log.warning(f'Deleting index entry')
                    del self.index[filehash]
                else:
                    # otherwise, add it to orphans
                    self.index_orphans[filehash] = self.index[filehash]



    def _save_file_orphans(self):
        '''
        For each broken symlink:

            - try and get the original file hash from .filestore
            - try and get the original file hash from the index
                - if hash is found:
                    - try and get the master file for the hash
                        - symlink orphan to master
                - if hash is not found:
                    - die
        '''
        for orphan in self.file_orphans:
            try:
                # try to read hash from .filestore backup
                orphan_filename, orphan_hash = read_metadata(orphan)
            except FilestoreMetadataError:
                try:
                    # try and get the hash from the index
                    orphan_hash = self.index[orphan]
                except KeyError:
                    log.error(f'Could not find hash for orphan {orphan}')
                    continue

            try:
                master = (self.dir / self.index[orphan_hash]['master_file']).resolve()
            except KeyError:
                log.error(f'Hash for orphan {orphan} not found in index')
                continue

            if master.exists():
                log.info(f'Rescued orphan file {orphan}, master is {master}')
                self.symlink_file(orphan, master)
            else:
                log.error(f'Master for {orphan} is missing, adding to orphans')
                self.index_orphans[orphan_hash] = self.index[orphan_hash]


    def _save_index_orphans(self):

        for orphan_hash, orphan_files in list(self.index_orphans.items()):
            log.critical('The following files are orphaned because of deleted master file')
            for orphan in orphan_files:
                log.critical(f'    {orphan}')



    def extract_files(self):
        '''
        Scans the filestore for compressed files and attempts to extract them
        If extraction is successful, the archive is deleted
        Index is automatically updated when finished
        '''

        for filename in self.files:
            if not filename.is_symlink():
                try:
                    filehash = self.index.hash(filename)
                except FilestoreHashError as e:
                    log.error(e)
                    continue
                d = Decompress(filename, filehash)
                success = d.decompress_if_archive()
                if success:
                    try:
                        for child in self.index[filehash]['child_files']:
                            log.info(f'    Replacing child {child} with symlink to extracted dir')
                            (self.dir / child).unlink()
                            Path(f'{self.dir / child}.extracted').symlink_to(d.extract_dir)
                        log.info(f'    Removing index entry for {filename}')
                        del self.index[filehash]
                    except KeyError:
                        pass

        self.update_index()



    def list_files(self, path, include_symlinks=False):

        path = Path(path)

        for dir_name, dir_list, file_list in os.walk(path, followlinks=False):
            log.debug(f'Found dir {dir_name}')
            for f in file_list:
                file = Path(dir_name) / f
                if include_symlinks or not file.is_symlink():
                    yield file


    def symlink_file(self, duplicate_file, master):
        '''
        deletes duplicate_file and replaces it with a symlink to master_file
        '''

        master = Path(master).resolve()

        if not master.is_file():
            log.error(f'Error linking {duplicate_file} to {master}, master does not exist!')
            return

        # if not already linked correctly, continue
        if not duplicate_file.resolve() == master:

            log.warning(f'Unlinking duplicate file {duplicate_file}')
            try:
                try:
                    duplicate_file_hash = self.index.hash(duplicate_file)
                except FilestoreHashError as e:
                    log.error(e)
                    return

                write_metadata(duplicate_file, duplicate_file_hash, master)
                duplicate_file.unlink()
            except OSError as e:
                log.warning(f'Error unlinking duplicate file {duplicate_file}: {e}')
                return

            log.warning(f'Linking duplicate file {duplicate_file.relative_to(self.dir)} to {master.relative_to(self.dir)}')
            try:
                duplicate_file.symlink_to(master)
            except OSError as e:
                log.error(f'Error symlinking {duplicate_file} to {master}: {e}')

        else:
            log.debug(f'{duplicate_file} is already symlinked to {master}')